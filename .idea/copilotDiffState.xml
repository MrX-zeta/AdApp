<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/AdApp-Backend/bin/main/com/adapp/backend/Application.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/AdApp-Backend/bin/main/com/adapp/backend/Application.kt" />
              <option name="originalContent" value="package com.adapp.backend&#10;&#10;import com.adapp.examples.configureDatabases&#10;import com.adapp.examples.configureFrameworks&#10;import com.adapp.examples.configureRouting&#10;import com.adapp.examples.configureSecurity&#10;import com.adapp.examples.configureSerialization&#10;import com.adapp.backend.User.Infrastructure.Routes.configureRouting as configureUserRouting&#10;import io.ktor.server.application.*&#10;import io.ktor.server.cio.EngineMain&#10;&#10;fun main(args: Array&lt;String&gt;) {&#10;    // Set properties to avoid netty-specific warnings if any netty jars remain&#10;    System.setProperty(&quot;io.netty.noUnsafe&quot;, &quot;true&quot;)&#10;    System.setProperty(&quot;io.netty.tryReflectionSetAccessible&quot;, &quot;false&quot;)&#10;    EngineMain.main(args)&#10;}&#10;&#10;fun Application.module() {&#10;    configureSecurity()&#10;    configureFrameworks()&#10;    configureSerialization()&#10;    configureDatabases()&#10;    configureRouting()&#10;    configureUserRouting()&#10;}" />
              <option name="updatedContent" value="package com.adapp.backend&#13;&#10;&#13;&#10;import com.adapp.examples.configureDatabases&#13;&#10;import com.adapp.examples.configureFrameworks&#13;&#10;import com.adapp.examples.configureRouting&#13;&#10;import com.adapp.examples.configureSecurity&#13;&#10;import com.adapp.examples.configureSerialization&#13;&#10;import com.adapp.backend.User.Infrastructure.Routes.configureRouting as configureUserRouting&#13;&#10;import com.adapp.backend.Artist.Infrastructure.Routes.configureArtistRouting as configureArtistRouting&#13;&#10;import io.ktor.server.application.*&#13;&#10;import io.ktor.server.cio.EngineMain&#13;&#10;&#13;&#10;fun main(args: Array&lt;String&gt;) {&#13;&#10;    // Set properties to avoid netty-specific warnings if any netty jars remain&#13;&#10;    System.setProperty(&quot;io.netty.noUnsafe&quot;, &quot;true&quot;)&#13;&#10;    System.setProperty(&quot;io.netty.tryReflectionSetAccessible&quot;, &quot;false&quot;)&#13;&#10;    EngineMain.main(args)&#13;&#10;}&#13;&#10;&#13;&#10;fun Application.module() {&#13;&#10;    configureSecurity()&#13;&#10;    configureFrameworks()&#13;&#10;    configureSerialization()&#13;&#10;    configureDatabases()&#13;&#10;    configureRouting()&#13;&#10;    configureUserRouting()&#13;&#10;    configureArtistRouting()&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/AdApp-Backend/src/main/kotlin/com/adapp/backend/Application.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/AdApp-Backend/src/main/kotlin/com/adapp/backend/Application.kt" />
              <option name="originalContent" value="package com.adapp.backend&#10;&#10;import com.adapp.examples.configureDatabases&#10;import com.adapp.examples.configureFrameworks&#10;import com.adapp.examples.configureRouting&#10;import com.adapp.examples.configureSecurity&#10;import com.adapp.examples.configureSerialization&#10;import com.adapp.backend.User.Infrastructure.Routes.configureRouting as configureUserRouting&#10;import io.ktor.server.application.*&#10;import io.ktor.server.cio.EngineMain&#10;&#10;fun main(args: Array&lt;String&gt;) {&#10;    // Set properties to avoid netty-specific warnings if any netty jars remain&#10;    System.setProperty(&quot;io.netty.noUnsafe&quot;, &quot;true&quot;)&#10;    System.setProperty(&quot;io.netty.tryReflectionSetAccessible&quot;, &quot;false&quot;)&#10;    EngineMain.main(args)&#10;}&#10;&#10;fun Application.module() {&#10;    configureSecurity()&#10;    configureFrameworks()&#10;    configureSerialization()&#10;    configureDatabases()&#10;    configureRouting()&#10;    configureUserRouting()&#10;}" />
              <option name="updatedContent" value="package com.adapp.backend&#10;&#10;import com.adapp.examples.configureDatabases&#10;import com.adapp.examples.configureFrameworks&#10;import com.adapp.examples.configureRouting&#10;import com.adapp.examples.configureSecurity&#10;import com.adapp.examples.configureSerialization&#10;import com.adapp.backend.User.Infrastructure.Routes.configureRouting as configureUserRouting&#10;import com.adapp.backend.Artist.Infrastructure.Routes.configureArtistRouting as configureArtistRouting&#10;import io.ktor.server.application.*&#10;import io.ktor.server.cio.EngineMain&#10;&#10;fun main(args: Array&lt;String&gt;) {&#10;    // Set properties to avoid netty-specific warnings if any netty jars remain&#10;    System.setProperty(&quot;io.netty.noUnsafe&quot;, &quot;true&quot;)&#10;    System.setProperty(&quot;io.netty.tryReflectionSetAccessible&quot;, &quot;false&quot;)&#10;    EngineMain.main(args)&#10;}&#10;&#10;fun Application.module() {&#10;    configureSecurity()&#10;    configureFrameworks()&#10;    configureSerialization()&#10;    configureDatabases()&#10;    configureRouting()&#10;    configureUserRouting()&#10;    configureArtistRouting()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/AdApp-Backend/src/main/kotlin/com/adapp/backend/Artist/Infrastructure/Controllers/KtorArtistController.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/AdApp-Backend/src/main/kotlin/com/adapp/backend/Artist/Infrastructure/Controllers/KtorArtistController.kt" />
              <option name="originalContent" value="package com.adapp.backend.Artist.Infrastructure.Controllers&#10;&#10;import com.adapp.backend.Artist.Domain.Models.Artist&#10;import com.adapp.backend.Artist.Domain.Models.ArtistContactNum&#10;import com.adapp.backend.Artist.Domain.Models.ArtistFotoUrl&#10;import com.adapp.backend.Artist.Domain.Models.ArtistDTO&#10;import com.adapp.backend.Artist.Domain.Repositories.ArtistRepository&#10;import com.adapp.backend.User.Domain.Exceptions.UserNotFoundError&#10;import com.adapp.backend.User.Domain.Models.UserEmail&#10;import com.adapp.backend.User.Domain.Models.UserId&#10;import com.adapp.backend.User.Domain.Models.UserName&#10;import com.adapp.backend.User.Domain.Models.UserPsswd&#10;import com.adapp.backend.User.Domain.Models.UserRol&#10;&#10;class KtorArtistController(private val artistRepo: ArtistRepository) {&#10;    fun getAll(): List&lt;ArtistDTO&gt; {&#10;        return artistRepo.getAllArtists().map { artist -&gt;&#10;            ArtistDTO(&#10;                id = artist.Usuarioid.value,&#10;                nombre = artist.nombre.value,&#10;                correo = artist.correo.value,&#10;                contrasena = artist.contrasena.value,&#10;                rol = artist.rol.value,&#10;                fotoUrl = artist.fotoUrl.value,&#10;                redesSociales = &quot;&quot;,&#10;                contactNum = artist.contactNum.value&#10;            )&#10;        }&#10;    }&#10;&#10;    fun getOneById(id: Int): ArtistDTO {&#10;        val artist = artistRepo.getOneById(UserId(id)) ?: throw UserNotFoundError(&quot;Artist not found&quot;)&#10;        return ArtistDTO(&#10;            id = artist.Usuarioid.value,&#10;            nombre = artist.nombre.value,&#10;            correo = artist.correo.value,&#10;            contrasena = artist.contrasena.value,&#10;            rol = artist.rol.value,&#10;            fotoUrl = artist.fotoUrl.value,&#10;            redesSociales = &quot;&quot;,&#10;            contactNum = artist.contactNum.value&#10;        )&#10;    }&#10;&#10;    fun create(id: Int, name: String, email: String, passwd: String, rol: String, fotoUrl: String, contactNum: String) {&#10;        // Convertir createdAt si es necesario; el dominio actual no usa createdAt en User&#10;        val artist = Artist(&#10;            UserId(id),&#10;            UserName(name),&#10;            UserEmail(email),&#10;            UserPsswd(passwd),&#10;            UserRol(rol),&#10;            ArtistFotoUrl(fotoUrl),&#10;            ArtistContactNum(contactNum)&#10;        )&#10;        artistRepo.create(artist)&#10;    }&#10;&#10;    fun edit(id: Int, name: String, email: String, passwd: String, rol: String, fotoUrl: String, contactNum: String) {&#10;        artistRepo.getOneById(UserId(id)) ?: throw UserNotFoundError(&quot;Artist not found&quot;)&#10;        val updated = Artist(&#10;            UserId(id),&#10;            UserName(name),&#10;            UserEmail(email),&#10;            UserPsswd(passwd),&#10;            UserRol(rol),&#10;            ArtistFotoUrl(fotoUrl),&#10;            ArtistContactNum(contactNum)&#10;        )&#10;        artistRepo.edit(updated)&#10;    }&#10;&#10;    fun delete(id: Int) {&#10;        artistRepo.getOneById(UserId(id)) ?: throw UserNotFoundError(&quot;Artist not found&quot;)&#10;        artistRepo.delete(UserId(id))&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.adapp.backend.Artist.Infrastructure.Controllers&#10;&#10;import com.adapp.backend.Artist.Domain.Models.Artist&#10;import com.adapp.backend.Artist.Domain.Models.ArtistContactNum&#10;import com.adapp.backend.Artist.Domain.Models.ArtistFotoUrl&#10;import com.adapp.backend.Artist.Domain.Models.ArtistDTO&#10;import com.adapp.backend.Artist.Domain.Repositories.ArtistRepository&#10;import com.adapp.backend.User.Domain.Exceptions.UserNotFoundError&#10;import com.adapp.backend.User.Domain.Models.UserEmail&#10;import com.adapp.backend.User.Domain.Models.UserId&#10;import com.adapp.backend.User.Domain.Models.UserName&#10;import com.adapp.backend.User.Domain.Models.UserPsswd&#10;import com.adapp.backend.User.Domain.Models.UserRol&#10;&#10;class KtorArtistController(private val artistRepo: ArtistRepository) {&#10;    fun getAll(): List&lt;ArtistDTO&gt; {&#10;        return artistRepo.getAllArtists().map { artist -&gt;&#10;            ArtistDTO(&#10;                id = artist.Usuarioid.value,&#10;                nombre = artist.nombre.value,&#10;                correo = artist.correo.value,&#10;                contrasena = artist.contrasena.value,&#10;                rol = artist.rol.value,&#10;                fotoUrl = artist.fotoUrl.value,&#10;                redesSociales = &quot;&quot;,&#10;                contactNum = artist.contactNum.value&#10;            )&#10;        }&#10;    }&#10;&#10;    fun getOneById(id: Int): ArtistDTO {&#10;        val artist = artistRepo.getOneById(UserId(id)) ?: throw UserNotFoundError(&quot;Artist not found&quot;)&#10;        return ArtistDTO(&#10;            id = artist.Usuarioid.value,&#10;            nombre = artist.nombre.value,&#10;            correo = artist.correo.value,&#10;            contrasena = artist.contrasena.value,&#10;            rol = artist.rol.value,&#10;            fotoUrl = artist.fotoUrl.value,&#10;            redesSociales = &quot;&quot;,&#10;            contactNum = artist.contactNum.value&#10;        )&#10;    }&#10;&#10;    fun create(id: Int, name: String, email: String, passwd: String, rol: String, fotoUrl: String, contactNum: String) {&#10;        // Convertir createdAt si es necesario; el dominio actual no usa createdAt en User&#10;        val artist = Artist(&#10;            UserId(id),&#10;            UserName(name),&#10;            UserEmail(email),&#10;            UserPsswd(passwd),&#10;            UserRol(rol),&#10;            ArtistFotoUrl(fotoUrl),&#10;            ArtistContactNum(contactNum)&#10;        )&#10;        artistRepo.create(artist)&#10;    }&#10;&#10;    /**&#10;     * Edita un artista. Permite cambiar el id: si `newId` != `oldId` se creará un nuevo artista con el nuevo id&#10;     * y se eliminará el antiguo (siempre que no exista ya un artista con `newId`).&#10;     * Lanza IllegalArgumentException si `newId` ya está en uso.&#10;     */&#10;    fun edit(oldId: Int, newId: Int, name: String, email: String, passwd: String, rol: String, fotoUrl: String, contactNum: String) {&#10;        // Verificar que el artista original existe&#10;        val existing = artistRepo.getOneById(UserId(oldId)) ?: throw UserNotFoundError(&quot;Artist not found&quot;)&#10;&#10;        // Si el id cambia, comprobar que el nuevo id no esté en uso&#10;        if (oldId != newId) {&#10;            val conflict = artistRepo.getOneById(UserId(newId))&#10;            if (conflict != null) {&#10;                throw IllegalArgumentException(&quot;Artist with id $newId already exists&quot;)&#10;            }&#10;&#10;            // Crear nuevo artista con el nuevo id y eliminar el antiguo&#10;            val created = Artist(&#10;                UserId(newId),&#10;                UserName(name),&#10;                UserEmail(email),&#10;                UserPsswd(passwd),&#10;                UserRol(rol),&#10;                ArtistFotoUrl(fotoUrl),&#10;                ArtistContactNum(contactNum)&#10;            )&#10;            artistRepo.create(created)&#10;            artistRepo.delete(UserId(oldId))&#10;            return&#10;        }&#10;&#10;        // Si no cambia el id, actualizar normalmente&#10;        val updated = Artist(&#10;            existing.Usuarioid,&#10;            UserName(name),&#10;            UserEmail(email),&#10;            UserPsswd(passwd),&#10;            UserRol(rol),&#10;            ArtistFotoUrl(fotoUrl),&#10;            ArtistContactNum(contactNum)&#10;        )&#10;        artistRepo.edit(updated)&#10;    }&#10;&#10;    fun delete(id: Int) {&#10;        artistRepo.getOneById(UserId(id)) ?: throw UserNotFoundError(&quot;Artist not found&quot;)&#10;        artistRepo.delete(UserId(id))&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>