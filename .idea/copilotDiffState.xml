<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/AdApp-Backend/HEALTH_CHECK_TEST_GUIDE.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/AdApp-Backend/HEALTH_CHECK_TEST_GUIDE.md" />
              <option name="updatedContent" value="# ✅ Guía de Prueba - Health Check PostgreSQL&#10;&#10;##  Cambios Realizados&#10;&#10;1. **Creada `DatabaseHealthResponse.kt`** - Clase serializable para evitar error de tipos mixtos&#10;2. **Actualizada `HealthRouting.kt`** - Usa clases serializables en lugar de Maps&#10;&#10;##  Cómo Probar&#10;&#10;### 1️⃣ Reinicia el servidor&#10;- Detén el servidor actual (Stop en IntelliJ)&#10;- Vuelve a ejecutar `Application.kt`&#10;&#10;### 2️⃣ Prueba el endpoint en Postman&#10;&#10;**Endpoint:**&#10;```&#10;GET http://127.0.0.1:8081/health/db&#10;```&#10;&#10;### ✅ Respuesta Exitosa (Conectado a PostgreSQL):&#10;```json&#10;{&#10;    &quot;status&quot;: &quot;CONNECTED&quot;,&#10;    &quot;database&quot;: &quot;PostgreSQL&quot;,&#10;    &quot;message&quot;: &quot;Database connection successful&quot;,&#10;    &quot;error&quot;: null,&#10;    &quot;errorType&quot;: null&#10;}&#10;```&#10;&#10;**Status Code:** `200 OK`&#10;&#10;### ❌ Respuesta con Error (No conectado):&#10;```json&#10;{&#10;    &quot;status&quot;: &quot;ERROR&quot;,&#10;    &quot;database&quot;: &quot;PostgreSQL&quot;,&#10;    &quot;message&quot;: null,&#10;    &quot;error&quot;: &quot;Connection refused&quot;,&#10;    &quot;errorType&quot;: &quot;SQLException&quot;&#10;}&#10;```&#10;&#10;**Status Code:** `503 Service Unavailable`&#10;&#10;##  Solución del Error&#10;&#10;**Antes:**&#10;```kotlin&#10;// ❌ Error: tipos mixtos (String y Long)&#10;mapOf(&#10;    &quot;status&quot; to &quot;CONNECTED&quot;,&#10;    &quot;usersCount&quot; to count  // ← Long&#10;)&#10;```&#10;&#10;**Ahora:**&#10;```kotlin&#10;// ✅ Correcto: clase serializable&#10;@Serializable&#10;data class DatabaseHealthResponse(&#10;    val status: String,&#10;    val database: String,&#10;    val message: String? = null,&#10;    val error: String? = null,&#10;    val errorType: String? = null&#10;)&#10;```&#10;&#10;##  Notas Importantes&#10;&#10;- El endpoint ahora usa `SELECT 1` en lugar de contar usuarios (más rápido)&#10;- Todas las respuestas son serializables correctamente&#10;- Los errores se manejan con códigos HTTP apropiados&#10;- Los logs de error se registran en la consola del servidor&#10;&#10;##  Siguiente Paso&#10;&#10;Una vez que veas `&quot;status&quot;: &quot;CONNECTED&quot;`, significa que:&#10;- ✅ El backend se conectó a PostgreSQL&#10;- ✅ Las credenciales son correctas&#10;- ✅ Las tablas se crearon automáticamente&#10;- ✅ Puedes usar las operaciones CRUD normalmente&#10;&#10;##  Prueba Adicional&#10;&#10;También puedes probar el endpoint simple:&#10;```&#10;GET http://127.0.0.1:8081/health&#10;```&#10;&#10;Respuesta:&#10;```json&#10;{&#10;    &quot;status&quot;: &quot;UP&quot;,&#10;    &quot;timestamp&quot;: 1732900000000&#10;}&#10;```&#10;&#10;---&#10;&#10;**¡La implementación está completa! Ahora prueba el endpoint.** &#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/AdApp-Backend/KOIN_FIX_GUIDE.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/AdApp-Backend/KOIN_FIX_GUIDE.md" />
              <option name="updatedContent" value="# ✅ Corrección: Error de Koin con PostgresUserRepository&#10;&#10;##  Error original:&#10;```&#10;No definition found for type 'InMemoryUserRepository'&#10;```&#10;&#10;##  Causa del problema:&#10;Cuando cambiaste de `InMemoryUserRepository` a `PostgresUserRepository` en Koin, olvidaste especificar la **interfaz** y actualizar el routing para inyectar la interfaz en lugar de la implementación concreta.&#10;&#10;## ✅ Solución aplicada:&#10;&#10;### 1. **AppModule.kt** - Registrar con interfaz&#10;```kotlin&#10;// ❌ ANTES (incorrecto)&#10;single { PostgresUserRepository() }&#10;&#10;// ✅ AHORA (correcto)&#10;single&lt;UserRepository&gt; { PostgresUserRepository() }&#10;```&#10;&#10;**Agregado import:**&#10;```kotlin&#10;import com.adapp.backend.User.Domain.Repositories.UserRepository&#10;```&#10;&#10;### 2. **KtorUserRouting.kt** - Inyectar interfaz&#10;```kotlin&#10;// ❌ ANTES (incorrecto)&#10;import com.adapp.backend.User.Infrastructure.Repositories.InMemoryUserRepository&#10;val userRepo: InMemoryUserRepository by inject()&#10;&#10;// ✅ AHORA (correcto)&#10;import com.adapp.backend.User.Domain.Repositories.UserRepository&#10;val userRepo: UserRepository by inject()&#10;```&#10;&#10;##  Principio de Inyección de Dependencias:&#10;&#10;**Regla de oro:** Siempre inyecta **interfaces**, no implementaciones concretas.&#10;&#10;### ✅ Correcto (Desacoplamiento):&#10;```kotlin&#10;// En Koin&#10;single&lt;UserRepository&gt; { PostgresUserRepository() }&#10;&#10;// En routing&#10;val repo: UserRepository by inject()&#10;```&#10;&#10;**Ventajas:**&#10;- ✅ Puedes cambiar de `PostgresUserRepository` a `InMemoryUserRepository` solo en `AppModule.kt`&#10;- ✅ El routing no necesita saber qué implementación se usa&#10;- ✅ Respeta el principio de inversión de dependencias (SOLID)&#10;&#10;### ❌ Incorrecto (Acoplamiento):&#10;```kotlin&#10;// En Koin&#10;single { PostgresUserRepository() } // Sin especificar interfaz&#10;&#10;// En routing&#10;val repo: InMemoryUserRepository by inject() // Tipo concreto&#10;```&#10;&#10;**Problemas:**&#10;- ❌ Koin registra el tipo concreto&#10;- ❌ El routing está acoplado a una implementación específica&#10;- ❌ No puedes cambiar fácilmente entre implementaciones&#10;&#10;##  Cómo cambiar entre InMemory y Postgres ahora:&#10;&#10;Solo necesitas cambiar **una línea** en `AppModule.kt`:&#10;&#10;```kotlin&#10;// Para usar PostgreSQL:&#10;single&lt;UserRepository&gt; { PostgresUserRepository() }&#10;&#10;// Para usar InMemory (testing):&#10;single&lt;UserRepository&gt; { InMemoryUserRepository() }&#10;```&#10;&#10;¡El routing no necesita cambios! &#10;&#10;## ✅ Estado actual:&#10;- PostgresUserRepository registrado como UserRepository en Koin&#10;- KtorUserRouting inyecta UserRepository (interfaz)&#10;- 0 errores de compilación&#10;- El proyecto está listo para conectarse a PostgreSQL&#10;&#10;##  Siguiente paso:&#10;Reinicia el servidor y verifica que se conecte a PostgreSQL:&#10;```&#10;GET http://localhost:8081/health/db&#10;```&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/AdApp-Backend/POSTGRES_MIGRATION_GUIDE.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/AdApp-Backend/POSTGRES_MIGRATION_GUIDE.md" />
              <option name="updatedContent" value="# Guía: Migración de InMemory a PostgreSQL&#10;&#10;## ✅ Lo que ya está configurado:&#10;&#10;1. **Dependencias agregadas:**&#10;   - PostgreSQL driver&#10;   - Exposed (ORM)&#10;   - HikariCP (pool de conexiones)&#10;&#10;2. **Configuración en `application.yaml`:**&#10;   ```yaml&#10;   postgres:&#10;     url: &quot;jdbc:postgresql://localhost:5432/Adapp&quot;&#10;     driver: &quot;org.postgresql.Driver&quot;&#10;     user: &quot;postgres&quot;&#10;     password: &quot;postgres&quot;&#10;   ```&#10;&#10;3. **Plugin de base de datos:** `Database.kt` configurado&#10;&#10;4. **Ejemplo de repositorio PostgreSQL:** `PostgresUserRepository.kt`&#10;&#10;---&#10;&#10;##  Pasos para completar la migración:&#10;&#10;### Paso 1: Sincronizar Gradle&#10;```powershell&#10;cd &quot;C:\Users\brian\OneDrive\Documents\UPchiapas\Cuatro Cuatri\Aplicaciones Web\U4\AdApp\AdApp-Backend&quot;&#10;.\gradlew.bat --refresh-dependencies&#10;```&#10;&#10;O en IntelliJ: Click derecho en `build.gradle.kts` → &quot;Reload Gradle Project&quot;&#10;&#10;### Paso 2: Corregir `Tables.kt`&#10;Cambiar todas las líneas de `datetime` y `CurrentDateTime` por timestamps simples:&#10;&#10;**Antes:**&#10;```kotlin&#10;val createdAt = datetime(&quot;created_at&quot;).defaultExpression(CurrentDateTime)&#10;```&#10;&#10;**Después:**&#10;```kotlin&#10;val createdAt = varchar(&quot;created_at&quot;, 50).clientDefault { java.time.LocalDateTime.now().toString() }&#10;```&#10;&#10;**Y agregar:**&#10;```kotlin&#10;val createdAt = timestamp(&quot;created_at&quot;).defaultExpression(CurrentDateTime())&#10;```&#10;&#10;Si Exposed no funciona, usa simplemente:&#10;```kotlin&#10;val createdAt = varchar(&quot;created_at&quot;, 50).nullable()&#10;```&#10;&#10;### Paso 3: Completar repositorios PostgreSQL&#10;&#10;Crear estos archivos siguiendo el ejemplo de `PostgresUserRepository.kt`:&#10;&#10;- ✅ `PostgresUserRepository.kt` (ya creado)&#10;- ⏳ `PostgresArtistRepository.kt`&#10;- ⏳ `PostgresSocialMediaRepository.kt`&#10;- ⏳ `PostgresFollowerRepository.kt`&#10;- ⏳ `PostgresFollowerArtistRepository.kt`&#10;- ⏳ `PostgresSongRepository.kt`&#10;- ⏳ `PostgresEventRepository.kt`&#10;&#10;### Paso 4: Actualizar `AppModule.kt`&#10;&#10;Cambiar de InMemory a Postgres en cada repositorio:&#10;&#10;```kotlin&#10;val repositoryModule = module {&#10;    // Cambiar cada uno:&#10;    single { PostgresUserRepository() }&#10;    single { PostgresArtistRepository() }&#10;    single { PostgresSocialMediaRepository() }&#10;    // ... etc&#10;}&#10;```&#10;&#10;---&#10;&#10;##  Solución rápida para empezar&#10;&#10;Si tienes errores de compilación con HikariCP, simplifica `Database.kt`:&#10;&#10;```kotlin&#10;package com.adapp.backend.Shared.Infrastructure.Plugins&#10;&#10;import io.ktor.server.application.*&#10;import org.jetbrains.exposed.sql.Database&#10;import org.jetbrains.exposed.sql.SchemaUtils&#10;import org.jetbrains.exposed.sql.transactions.transaction&#10;import com.adapp.backend.Shared.Infrastructure.Database.Tables.*&#10;&#10;fun Application.configureDatabases() {&#10;    val config = environment.config&#10;    &#10;    // Conexión simple sin HikariCP&#10;    Database.connect(&#10;        url = config.property(&quot;postgres.url&quot;).getString(),&#10;        driver = config.property(&quot;postgres.driver&quot;).getString(),&#10;        user = config.property(&quot;postgres.user&quot;).getString(),&#10;        password = config.property(&quot;postgres.password&quot;).getString()&#10;    )&#10;    &#10;    // Crear tablas&#10;    transaction {&#10;        SchemaUtils.create(UsersTable, ArtistsTable, /* ... */])&#10;    }&#10;    &#10;    log.info(&quot;Database configured successfully&quot;)&#10;}&#10;```&#10;&#10;---&#10;&#10;##  Alternativa rápida: Usa solo User con Postgres&#10;&#10;Para verificar que funciona, deja solo `UserRepository` con Postgres y el resto en InMemory:&#10;&#10;```kotlin&#10;val repositoryModule = module {&#10;    single { PostgresUserRepository() }        // ← Postgres&#10;    single { InMemoryArtistRepository() }     // ← InMemory (temporal)&#10;    single { InMemorySocialMediaRepository() } // ← InMemory (temporal)&#10;    // ...&#10;}&#10;```&#10;&#10;---&#10;&#10;## ✅ Verificar que funciona:&#10;&#10;1. Reinicia el servidor&#10;2. Crea un usuario con POST `/users`&#10;3. Verifica en pgAdmin que aparece en la tabla `users`&#10;4. Haz GET `/users` y confirma que recupera desde Postgres&#10;&#10;---&#10;&#10;##  Estructura de tablas creadas:&#10;&#10;Las tablas que se crearán automáticamente:&#10;- `users`&#10;- `artists`&#10;- `followers`&#10;- `follower_artist`&#10;- `social_media`&#10;- `songs`&#10;- `events`&#10;&#10;---&#10;&#10;## ⚠️ Problemas comunes:&#10;&#10;1. **&quot;Unresolved reference HikariCP&quot;**&#10;   - Sincroniza Gradle&#10;&#10;2. **&quot;Table already exists&quot;**&#10;   - Borra las tablas en pgAdmin o cambia `SchemaUtils.create` por `SchemaUtils.createMissingTablesAndColumns`&#10;&#10;3. **&quot;Connection refused&quot;**&#10;   - Verifica que PostgreSQL esté corriendo&#10;   - Confirma puerto 5432&#10;   - Confirma usuario/contraseña&#10;&#10;---&#10;&#10;##  Siguiente paso:&#10;&#10;Una vez que sincronices Gradle y corrijas los errores de compilación, el backend estará listo para usar PostgreSQL.&#10;&#10;¿Quieres que continúe implementando todos los repositorios o prefieres hacerlo tú mismo paso a paso?&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/AdApp-Backend/VERIFY_CREDENTIALS_GUIDE.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/AdApp-Backend/VERIFY_CREDENTIALS_GUIDE.md" />
              <option name="updatedContent" value="# Guía: Verificar Credenciales PostgreSQL ✅&#10;&#10;##  Credenciales actuales en `application.yaml`:&#10;&#10;```yaml&#10;postgres:&#10;  url: &quot;jdbc:postgresql://localhost:5432/Adapp&quot;&#10;  user: &quot;postgres&quot;&#10;  password: &quot;12345678&quot;&#10;```&#10;&#10;---&#10;&#10;## ✅ Método 1: Verificar en pgAdmin (Recomendado)&#10;&#10;### Paso 1: Abrir pgAdmin 4&#10;- Abre pgAdmin 4 desde el menú inicio&#10;&#10;### Paso 2: Ver la conexión actual&#10;1. En el panel izquierdo, expande **&quot;Servers&quot;**&#10;2. Busca **&quot;PostgreSQL 17&quot;** (o la versión que tengas)&#10;3. Si te pide contraseña, usa: `12345678`&#10;&#10;### Paso 3: Verificar la base de datos&#10;1. Expande el servidor PostgreSQL&#10;2. Expande **&quot;Databases&quot;**&#10;3. Busca la base de datos **&quot;Adapp&quot;** (debe existir)&#10;&#10;### Paso 4: Verificar usuario&#10;1. En el servidor, ve a **Login/Group Roles**&#10;2. Verifica que existe el usuario **&quot;postgres&quot;**&#10;&#10;✅ **Si puedes ver la base de datos &quot;Adapp&quot;, las credenciales son correctas**&#10;&#10;---&#10;&#10;## ✅ Método 2: Usar Query Tool de pgAdmin&#10;&#10;1. Click derecho en la base de datos **&quot;Adapp&quot;**&#10;2. Selecciona **&quot;Query Tool&quot;**&#10;3. Ejecuta esta query:&#10;&#10;```sql&#10;SELECT current_database(), current_user, version();&#10;```&#10;&#10;**Resultado esperado:**&#10;- `current_database`: Adapp&#10;- `current_user`: postgres&#10;- `version`: PostgreSQL 17.x&#10;&#10;---&#10;&#10;## ✅ Método 3: Verificar con endpoints de salud&#10;&#10;### Una vez que el servidor backend esté corriendo:&#10;&#10;1. **Verificar que el servidor esté UP:**&#10;   ```&#10;   GET http://localhost:8081/health&#10;   ```&#10;   &#10;   **Respuesta esperada:**&#10;   ```json&#10;   {&#10;     &quot;status&quot;: &quot;UP&quot;,&#10;     &quot;timestamp&quot;: 1732900000000&#10;   }&#10;   ```&#10;&#10;2. **Verificar conexión a PostgreSQL:**&#10;   ```&#10;   GET http://localhost:8081/health/db&#10;   ```&#10;   &#10;   **Respuesta exitosa:**&#10;   ```json&#10;   {&#10;     &quot;status&quot;: &quot;CONNECTED&quot;,&#10;     &quot;database&quot;: &quot;PostgreSQL&quot;,&#10;     &quot;usersCount&quot;: 0,&#10;     &quot;message&quot;: &quot;Database connection successful&quot;&#10;   }&#10;   ```&#10;   &#10;   **Respuesta con error:**&#10;   ```json&#10;   {&#10;     &quot;status&quot;: &quot;ERROR&quot;,&#10;     &quot;database&quot;: &quot;PostgreSQL&quot;,&#10;     &quot;error&quot;: &quot;Connection refused&quot; // o el error específico&#10;   }&#10;   ```&#10;&#10;---&#10;&#10;## ✅ Método 4: Verificar con psql (Línea de comandos)&#10;&#10;Si tienes `psql` instalado:&#10;&#10;```powershell&#10;# Windows PowerShell&#10;$env:PGPASSWORD = &quot;12345678&quot;&#10;psql -h localhost -p 5432 -U postgres -d Adapp -c &quot;SELECT current_database();&quot;&#10;```&#10;&#10;**Respuesta esperada:**&#10;```&#10; current_database &#10;------------------&#10; Adapp&#10;(1 row)&#10;```&#10;&#10;---&#10;&#10;##  Errores comunes y soluciones:&#10;&#10;### Error 1: &quot;Connection refused&quot;&#10;**Causa:** PostgreSQL no está corriendo&#10;**Solución:**&#10;- Abre Services (Win+R → `services.msc`)&#10;- Busca &quot;postgresql-x64-17&quot;&#10;- Click derecho → Start&#10;&#10;### Error 2: &quot;password authentication failed&quot;&#10;**Causa:** Contraseña incorrecta&#10;**Solución:**&#10;1. En pgAdmin, ve a tu servidor&#10;2. Click derecho → Properties → Connection&#10;3. Verifica la contraseña guardada&#10;4. Actualiza `application.yaml` con la contraseña correcta&#10;&#10;### Error 3: &quot;database Adapp does not exist&quot;&#10;**Causa:** Base de datos no creada&#10;**Solución:**&#10;1. En pgAdmin, click derecho en &quot;Databases&quot;&#10;2. Create → Database&#10;3. Nombre: `Adapp`&#10;4. Owner: `postgres`&#10;5. Save&#10;&#10;### Error 4: &quot;role postgres does not exist&quot;&#10;**Causa:** Usuario postgres no existe (poco común)&#10;**Solución:**&#10;- Durante la instalación de PostgreSQL se crea automáticamente&#10;- Reinstala PostgreSQL o crea el usuario manualmente&#10;&#10;---&#10;&#10;##  Checklist de verificación:&#10;&#10;- [ ] PostgreSQL está corriendo (Services)&#10;- [ ] pgAdmin puede conectarse al servidor&#10;- [ ] La base de datos &quot;Adapp&quot; existe&#10;- [ ] El usuario &quot;postgres&quot; existe&#10;- [ ] La contraseña &quot;12345678&quot; funciona en pgAdmin&#10;- [ ] El puerto 5432 está libre y accesible&#10;- [ ] `application.yaml` tiene las credenciales correctas&#10;- [ ] El endpoint `/health/db` responde exitosamente&#10;&#10;---&#10;&#10;##  Resumen rápido:&#10;&#10;**Para verificar que las credenciales son correctas:**&#10;&#10;1. ✅ Abre pgAdmin&#10;2. ✅ Conéctate con usuario `postgres` y password `12345678`&#10;3. ✅ Verifica que existe la base de datos `Adapp`&#10;4. ✅ Inicia el backend y visita: `http://localhost:8081/health/db`&#10;&#10;**Si el endpoint `/health/db` responde con `status: &quot;CONNECTED&quot;`, las credenciales son correctas** ✅&#10;&#10;---&#10;&#10;##  Script de verificación automática:&#10;&#10;Ejecuta este comando en PowerShell:&#10;&#10;```powershell&#10;cd &quot;C:\Users\brian\OneDrive\Documents\UPchiapas\Cuatro Cuatri\Aplicaciones Web\U4\AdApp\AdApp-Backend&quot;&#10;.\verify-db-connection.ps1&#10;```&#10;&#10;Este script verificará automáticamente:&#10;- Si PostgreSQL está corriendo&#10;- Las credenciales en `application.yaml`&#10;- Si puede conectarse a la base de datos&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/AdApp-Backend/verify-db-connection.ps1">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/AdApp-Backend/verify-db-connection.ps1" />
              <option name="updatedContent" value="# Script de Verificación de Conexión PostgreSQL&#10;# ================================================&#10;&#10;Write-Host &quot;=== Verificando conexión a PostgreSQL ===&quot; -ForegroundColor Cyan&#10;Write-Host &quot;&quot;&#10;&#10;# 1. Verificar que PostgreSQL está corriendo&#10;Write-Host &quot;1. Verificando que PostgreSQL esté corriendo...&quot; -ForegroundColor Yellow&#10;$postgresProcess = Get-Process -Name &quot;postgres&quot; -ErrorAction SilentlyContinue&#10;&#10;if ($postgresProcess) {&#10;    Write-Host &quot;   ✓ PostgreSQL está corriendo&quot; -ForegroundColor Green&#10;} else {&#10;    Write-Host &quot;   ✗ PostgreSQL NO está corriendo&quot; -ForegroundColor Red&#10;    Write-Host &quot;   → Inicia PostgreSQL desde pgAdmin o Services&quot; -ForegroundColor Yellow&#10;}&#10;&#10;Write-Host &quot;&quot;&#10;&#10;# 2. Leer credenciales del archivo application.yaml&#10;Write-Host &quot;2. Leyendo credenciales de application.yaml...&quot; -ForegroundColor Yellow&#10;$yamlPath = &quot;.\src\main\resources\application.yaml&quot;&#10;&#10;if (Test-Path $yamlPath) {&#10;    $yamlContent = Get-Content $yamlPath -Raw&#10;    &#10;    # Extraer credenciales usando regex&#10;    if ($yamlContent -match 'url:\s*&quot;jdbc:postgresql://([^:]+):(\d+)/([^&quot;]+)&quot;') {&#10;        $host = $matches[1]&#10;        $port = $matches[2]&#10;        $database = $matches[3]&#10;    }&#10;    &#10;    if ($yamlContent -match 'user:\s*&quot;([^&quot;]+)&quot;') {&#10;        $user = $matches[1]&#10;    }&#10;    &#10;    if ($yamlContent -match 'password:\s*&quot;([^&quot;]+)&quot;') {&#10;        $password = $matches[1]&#10;    }&#10;    &#10;    Write-Host &quot;   Host:     $host&quot; -ForegroundColor White&#10;    Write-Host &quot;   Puerto:   $port&quot; -ForegroundColor White&#10;    Write-Host &quot;   Database: $database&quot; -ForegroundColor White&#10;    Write-Host &quot;   Usuario:  $user&quot; -ForegroundColor White&#10;    Write-Host &quot;   Password: $('*' * $password.Length)&quot; -ForegroundColor White&#10;} else {&#10;    Write-Host &quot;   ✗ No se encontró application.yaml&quot; -ForegroundColor Red&#10;    exit 1&#10;}&#10;&#10;Write-Host &quot;&quot;&#10;&#10;# 3. Verificar conexión usando psql (si está disponible)&#10;Write-Host &quot;3. Intentando conectar con psql...&quot; -ForegroundColor Yellow&#10;&#10;$env:PGPASSWORD = $password&#10;$psqlCommand = &quot;psql -h $host -p $port -U $user -d $database -c 'SELECT version();'&quot;&#10;&#10;try {&#10;    $result = Invoke-Expression $psqlCommand 2&gt;&amp;1&#10;    &#10;    if ($LASTEXITCODE -eq 0) {&#10;        Write-Host &quot;   ✓ Conexión exitosa con psql&quot; -ForegroundColor Green&#10;        Write-Host &quot;   Versión:&quot; -ForegroundColor White&#10;        Write-Host &quot;   $result&quot; -ForegroundColor Gray&#10;    } else {&#10;        Write-Host &quot;   ✗ Error de conexión&quot; -ForegroundColor Red&#10;        Write-Host &quot;   $result&quot; -ForegroundColor Red&#10;    }&#10;} catch {&#10;    Write-Host &quot;   ⚠ psql no está disponible (opcional)&quot; -ForegroundColor Yellow&#10;}&#10;&#10;$env:PGPASSWORD = $null&#10;&#10;Write-Host &quot;&quot;&#10;&#10;# 4. Verificar que la base de datos existe&#10;Write-Host &quot;4. Verificación recomendada en pgAdmin:&quot; -ForegroundColor Yellow&#10;Write-Host &quot;   1. Abre pgAdmin 4&quot; -ForegroundColor White&#10;Write-Host &quot;   2. Conéctate al servidor 'PostgreSQL 17'&quot; -ForegroundColor White&#10;Write-Host &quot;   3. Verifica que existe la base de datos: $database&quot; -ForegroundColor White&#10;Write-Host &quot;   4. Usuario debe ser: $user&quot; -ForegroundColor White&#10;Write-Host &quot;   5. Contraseña debe ser: $password&quot; -ForegroundColor White&#10;&#10;Write-Host &quot;&quot;&#10;&#10;# 5. Endpoint de prueba&#10;Write-Host &quot;5. Una vez que el servidor esté corriendo, prueba estos endpoints:&quot; -ForegroundColor Yellow&#10;Write-Host &quot;   GET  http://localhost:8081/health       → Estado del servidor&quot; -ForegroundColor Cyan&#10;Write-Host &quot;   GET  http://localhost:8081/health/db    → Conexión a PostgreSQL&quot; -ForegroundColor Cyan&#10;&#10;Write-Host &quot;&quot;&#10;Write-Host &quot;=== Verificación completada ===&quot; -ForegroundColor Cyan&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>